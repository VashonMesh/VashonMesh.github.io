---
import Header from '../components/header.astro';
import Footer from '../components/footer.astro';
import '../global.css';

interface Props {
  title: string;
  maxWidth?: string;
  twoColumn?: boolean;
  floatingImages?: boolean;
  imageCount?: number;
  noWrapper?: boolean;
  showTOC?: boolean;
}

const { 
  title, 
  maxWidth = '1800px', 
  twoColumn = false,
  floatingImages = false,
  imageCount = 10,
  noWrapper = false,
  showTOC = false
} = Astro.props;

// Floating images setup
interface FloatingImageConfig {
  src: string;
  top: number;
  left: number;
  duration: number;
  keyframes: string;
  animationName: string;
  index: number;
}

let floatingImageItems: FloatingImageConfig[] = [];

if (floatingImages) {
  // Predefined list 
  const availableImages = [
    'hero-imgs/birds/bald-eagle.optimized.webp',
    'hero-imgs/birds/golden-pheasant.optimized.webp',
    'hero-imgs/birds/parrot.optimized.webp',
    'hero-imgs/devices/T-DECK-PLUS_7.optimized.webp',
    'hero-imgs/devices/m5-lora.optimized.webp',
    'hero-imgs/devices/Panel-Antenna.optimized.webp',
    'hero-imgs/solar/planet5.optimized.webp',
    'hero-imgs/solar/saturn.optimized.webp',
    'hero-imgs/solar/star.optimized.webp',
    'hero-imgs/devices/Wisblock_WisMesh_Pocket_V2_RAK.optimized.webp'
  ];
  
  const shuffledImages = [...availableImages]
    .sort(() => Math.random() - 0.5)
    .slice(0, Math.min(imageCount, availableImages.length));

  // Helper functions for random generation
  const randomRange = (min: number, max: number) => Math.random() * (max - min) + min;

  floatingImageItems = shuffledImages.map((src, index) => {
    const animationName = `staticFloat_${index}`;
    // Generate keyframes
    const waypoints = Math.random() > 0.5 ? 4 : 2;
    const percentages = waypoints === 4 ? [0, 25, 50, 75, 100] : [0, 50, 100];
    
    let keyframeContent = '';
    
    percentages.forEach(percent => {
        const translateX = percent === 0 
        ? randomRange(-40, -15)
        : percent === 100
            ? randomRange(115, 145)
            : randomRange(percent * 1.2 - 30, percent * 1.2 + 10);
        
        const translateY = randomRange(-20, 20);
        const scale = randomRange(0.7, 1.5);
        const rotate = randomRange(-30, 30);
        
        keyframeContent += `
        ${percent}% { transform: translate(${translateX}vw, ${translateY}vh) scale(${scale}) rotate(${rotate}deg); }`;
    });

    const keyframes = `@keyframes ${animationName} { ${keyframeContent} }`;
    
    return {
        src,
        top: randomRange(5, 85),
        left: randomRange(5, 90),
        duration: randomRange(33, 50),
        keyframes,
        animationName,
        index
    };
  });
}
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="description" content="VashonMesh - Community mesh networks connecting neighbors" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="sitemap" href="/sitemap-index.xml" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="generator" content={Astro.generator} />
    
    <!-- DNS prefetch for external resources -->
    <link rel="dns-prefetch" href="https://gc.zgo.at">
    
    <!-- Critical CSS - most important styles inlined for immediate render -->
    <style is:inline>
      :root {
        --bg-primary: #ffffff;
        --bg-secondary: #f9fafb;
        --text-primary: #111827;
      }
      .dark {
        --bg-primary: #0a0a0a;
        --bg-secondary: #1a1a2e;
        --text-primary: #f9fafb;
      }
      * { box-sizing: border-box; }
      body {
        margin: 0;
        padding: 0;
        background: var(--bg-secondary);
        color: var(--text-primary);
        font-family: system-ui, sans-serif;
      }
      .rubik-maps-regular {
        font-family: "Comic Sans MS", "Marker Felt", fantasy, system-ui, sans-serif;
      }
    </style>
    
    <title>{title}</title>
    
    <!-- Allow pages to inject custom SEO meta tags -->
    <slot name="head" />
  </head>
  <body>
    <div class={floatingImages ? "site-wrapper" : ""}>
      <Header />
      {noWrapper ? (
        <slot />
      ) : showTOC ? (
        <div class={`mx-auto px-4 py-8 w-full flex-1 ${floatingImages ? 'page-content' : ''}`} style={`max-width: ${maxWidth}`}>
          <div class="toc-container">
            <!-- Mobile TOC Toggle Button -->
            <button id="toc-toggle" class="toc-toggle">
              <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />
              </svg>
              <span>Table of Contents</span>
            </button>

            <!-- Main Content -->
            <main class="toc-main-content">
              <slot />
            </main>

            <!-- TOC Sidebar -->
            <aside id="toc-sidebar" class="toc-sidebar">
              <div class="toc-sticky">
                <button id="toc-close" class="toc-close lg:hidden">
                  <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                  </svg>
                </button>
                <h3 class="toc-heading">Table of Contents</h3>
                <nav id="toc-nav" class="toc-nav">
                  <!-- TOC will be generated here by JavaScript -->
                </nav>
              </div>
            </aside>
          </div>
        </div>
      ) : (
        <div class={`mx-auto px-4 py-8 w-full flex-1 ${floatingImages ? 'page-content' : ''}`} style={`max-width: ${maxWidth}`}>
          {twoColumn ? (
            <div class="grid grid-cols-1 md:grid-cols-[1fr_300px] gap-8 items-start">
              <main class="min-w-0 prose">
                <slot />
              </main>
              <aside class="md:sticky md:top-4">
                <slot name="sidebar" />
              </aside>
            </div>
          ) : (
            <main class="max-w-full prose">
              <slot />
            </main>
          )}
        </div>
      )}
      <Footer />
    </div>

    <!-- Floating images container rendered after main content -->
    {floatingImages && (
      <div class="floating-container">
        <style set:html={floatingImageItems.map(item => item.keyframes).join('\n')} />
        {floatingImageItems.map(item => (
            <div class="floating-image" 
                 id={`float-${item.index}`}
                 style={`
                    top: ${item.top}%; 
                    left: ${item.left}%; 
                    animation-name: ${item.animationName}; 
                    animation-duration: ${item.duration}s; 
                    animation-timing-function: linear; 
                    animation-fill-mode: forwards;
                 `}>
              <span class="img-wrapper">
                <img 
                    src={`/${item.src}`} 
                    alt="" 
                    width="80" 
                    height="80" 
                    style="max-width: 80px; width: 80px; height: auto;" 
                    loading="lazy" 
                    decoding="async"
                    fetchpriority="low"
                />
              </span>
            </div>
        ))}
      </div>
    )}
  </body>
  <!-- Web analytics -->
  <!-- Large script slows page loads...turn on after rest settles down.
  script is:inline data-goatcounter="https://vashonmesh.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script -->
</html>

<style is:global>
  /* Base styles handled in global.css */
  
  /* Layout-specific body styling */
  body {
    min-height: 100vh;
    display: flex;
    flex-direction: column;
  }

  /* Responsive breakpoint for two-column layout */
  @media (max-width: 768px) {
    .md\:grid-cols-\[1fr_300px\] {
      grid-template-columns: 1fr;
    }
  }

  /* Max width constraint for XL screens */
  @media (min-width: 1280px) {
    .mx-auto.px-4.py-8 {
      max-width: min(75vw, var(--max-width, 1800px)) !important;
    }
  }

  /* TOC Container Layout */
  .toc-container {
    max-width: 1600px;
    margin: 0 auto;
    padding: 0;
    display: flex;
    flex-direction: column;
    gap: 2rem;
  }

  @media (min-width: 769px) {
    .toc-container {
      display: grid;
      grid-template-columns: 220px 1fr;
      gap: 3rem;
    }
  }

  .toc-main-content {
    max-width: 900px;
    width: 100%;
    min-width: 0;
  }

  /* Mobile TOC Toggle Button */
  .toc-toggle {
    position: fixed;
    bottom: 2rem;
    right: 1.5rem;
    z-index: 100;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.75rem 1rem;
    background-color: #2563eb;
    color: white;
    border-radius: 9999px;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    border: none;
    cursor: pointer;
    font-weight: 600;
    font-size: 0.875rem;
    transition: all 0.2s;
  }

  .toc-toggle svg {
    width: 1.25rem;
    height: 1.25rem;
  }

  @media (min-width: 769px) {
    .toc-toggle {
      display: none;
    }
  }

  .toc-toggle:hover {
    background-color: #1d4ed8;
    transform: translateY(-2px);
  }

  @media (min-width: 769px) {
    .toc-sidebar {
      display: block;
      grid-column: 1;
      grid-row: 1;
      width: 100%;
    }
    
    .toc-main-content {
      grid-column: 2;
      grid-row: 1;
    }
  }

  /* Mobile: Full Screen Overlay */
  @media (max-width: 768px) {
    .toc-sidebar {
      position: fixed;
      top: 0;
      right: 0;
      bottom: 0;
      width: 85%;
      max-width: 320px;
      background-color: var(--bg-primary);
      box-shadow: -4px 0 6px -1px rgba(0, 0, 0, 0.1);
      z-index: 2000;
      transform: translateX(100%);
      transition: transform 0.3s ease-in-out;
      overflow-y: auto;
    }

    .toc-sidebar.open {
      display: block;
      transform: translateX(0);
    }
  }

  .toc-sticky {
    background-color: var(--card-bg);
    border: 1px solid var(--border-color);
    border-radius: 0.5rem;
    padding: 1rem;
  }

  @media (min-width: 769px) {
    .toc-sticky {
      position: -webkit-sticky;
      position: sticky;
      top: 6rem;
      max-height: calc(100vh - 8rem);
      overflow-y: auto;
      overflow-x: hidden;
      width: 100%;
      scroll-behavior: smooth;
    }
  }

  @media (max-width: 768px) {
    .toc-sticky {
      position: static;
      height: 100%;
      max-height: none;
      border: none;
      border-radius: 0;
    }
  }

  .toc-close {
    position: absolute;
    top: 1rem;
    right: 1rem;
    background: none;
    border: none;
    color: var(--text-secondary);
    cursor: pointer;
    padding: 0.5rem;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 0.25rem;
    transition: all 0.2s;
  }

  @media (min-width: 769px) {
    .toc-close {
      display: none;
    }
  }

  .toc-close:hover {
    background-color: rgba(0, 0, 0, 0.05);
    color: var(--text-primary);
  }

  :global(.dark) .toc-close:hover {
    background-color: rgba(255, 255, 255, 0.05);
  }

  .toc-heading {
    font-size: 0.875rem;
    font-weight: 700;
    color: var(--text-primary);
    margin-bottom: 0.75rem;
    padding-bottom: 0.5rem;
    border-bottom: 2px solid var(--border-color);
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  .toc-nav :global(.toc-list) {
    list-style: none;
    padding: 0;
    margin: 0;
  }

  .toc-nav :global(.toc-item) {
    margin-bottom: 0;
  }

  .toc-nav :global(.toc-level-2) {
    margin-bottom: 0.75rem;
  }

  .toc-nav :global(.toc-level-3) {
    margin-left: 0.75rem;
    margin-bottom: 0.5rem;
  }

  .toc-nav :global(.toc-link) {
    display: block;
    padding: 0.4rem 0.5rem;
    color: var(--text-secondary);
    text-decoration: none;
    border-radius: 0.25rem;
    font-size: 0.8rem;
    line-height: 1.3;
    transition: all 0.2s;
    border-left: 3px solid transparent;
    scroll-margin: 2rem;
  }

  .toc-nav :global(.toc-link:hover) {
    background-color: rgba(37, 99, 235, 0.05);
    color: var(--text-primary);
    border-left-color: #2563eb;
  }

  .toc-nav :global(.toc-link.active) {
    background-color: rgba(37, 99, 235, 0.1);
    color: #2563eb;
    font-weight: 600;
    border-left-color: #2563eb;
    scroll-snap-align: center;
  }

  :global(.dark) .toc-nav :global(.toc-link:hover) {
    background-color: rgba(96, 165, 250, 0.1);
  }

  :global(.dark) .toc-nav :global(.toc-link.active) {
    background-color: rgba(96, 165, 250, 0.15);
    color: #60a5fa;
    border-left-color: #60a5fa;
  }
</style>

{floatingImages && (
  <style is:global>
    /* FloatingImages-specific light mode variables */
    html {
      --bg-primary: rgba(255, 255, 255, 0.85);
      --bg-secondary: rgba(249, 250, 251, 0.85);
      --header-bg: rgba(255, 255, 255, 0.95);
      --footer-bg: rgba(243, 244, 246, 0.95);
    }
    
    /* FloatingImages-specific dark mode overrides */
    html.dark {
      --bg-primary: rgba(10, 10, 10, 0.85);
      --bg-secondary: rgba(26, 26, 46, 0.85);
      --header-bg: rgba(17, 24, 39, 0.95);
      --footer-bg: rgba(31, 41, 55, 0.95);
    }

    /* FloatingImages-specific layout styles */
    html {
      background: #f9fafb;
      transition: background-color 0.3s ease;
      width: 100%;
      overflow-x: hidden;
    }

    html.dark {
      background: #0a0a0a;
    }

    body {
      background: transparent;
      overflow-x: hidden;
      position: relative;
      width: 100%;
      max-width: 100vw;
    }

    .site-wrapper {
      position: relative;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      width: 100%;
      max-width: 100vw;
    }

    header {
      position: relative;
      z-index: 100;
    }

    footer {
      position: relative;
      z-index: 100;
      margin-top: auto;
    }

    .page-content {
      flex: 1;
      position: relative;
      z-index: 3;
      pointer-events: none;
    }

    .floating-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: linear-gradient(135deg, #f9fafb 0%, #e5e7eb 50%, #f9fafb 100%);
      overflow: hidden;
      z-index: 2;
      pointer-events: none;
      transition: opacity 0.8s ease, background 0.3s ease;
      max-width: 100%;
      visibility: hidden;
      opacity: 0;
      contain: strict;
    }

    .floating-container.loaded {
      visibility: visible;
      opacity: 1;
    }

    html.dark .floating-container {
      background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #0a0a0a 100%);
    }

    .floating-image {
      position: absolute;
      pointer-events: auto;
      cursor: pointer;
      z-index: 1;
      width: 80px;
      height: auto;
      overflow: visible;
    }

    /* Pause animations until container is loaded */
    .floating-container:not(.loaded) .floating-image {
      animation-play-state: paused !important;
    }

    .floating-image:hover {
      z-index: 200 !important;
    }

    .img-wrapper {
      display: inline-block;
      width: 80px;
      height: auto;
      opacity: 0.5;
      transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
      transform: scale(1);
    }

    .floating-image:hover .img-wrapper {
      opacity: 1 !important;
      transform: scale(2.5) rotate(5deg) !important;
    }

    .floating-image img {
      display: block;
      max-width: 80px !important;
      width: 80px !important;
      height: auto !important;
      border-radius: 8px;
      transition: filter 0.3s ease;
    }

    html.dark .floating-image img {
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      .floating-image {
        width: 50px;
        height: auto;
      }
      
      .img-wrapper {
        width: 50px;
        height: auto;
      }
      
      .floating-image img {
        max-width: 50px !important;
        width: 50px !important;
      }
    }
  </style>
)}

<script>
  // Theme toggle functionality
  function initTheme() {
    const theme = localStorage.getItem('theme') || 'dark';
    if (theme === 'dark') {
      document.documentElement.classList.add('dark');
    } else {
      document.documentElement.classList.remove('dark');
    }
  }

  // Initialize theme immediately
  initTheme();

  // Add event listener after page loads
  document.addEventListener('DOMContentLoaded', () => {
    const toggle = document.getElementById('theme-toggle');
    if (toggle) {
      toggle.addEventListener('click', () => {
        const isDark = document.documentElement.classList.toggle('dark');
        localStorage.setItem('theme', isDark ? 'dark' : 'light');
      });
    }
  });
</script>

{showTOC && (
  <script>
    // Generate Table of Contents from headings
    function generateTOC() {
      const content = document.querySelector('.toc-main-content, .article-content');
      const tocNav = document.getElementById('toc-nav');
      const tocSidebar = document.getElementById('toc-sidebar');
      
      if (!content || !tocNav) return;
      
      const headings = content.querySelectorAll('h2, h3');
      
      if (headings.length === 0) {
        // No headings, hide TOC
        if (tocSidebar) tocSidebar.style.display = 'none';
        const toggle = document.getElementById('toc-toggle');
        if (toggle) toggle.style.display = 'none';
        return;
      }
      
      const tocList = document.createElement('ul');
      tocList.className = 'toc-list';
      
      headings.forEach((heading) => {
        // Skip if it's the "Table of Contents" heading itself
        if (heading.id === 'table-of-contents' || heading.id === 'contents') {
          (heading as HTMLElement).style.display = 'none';
          return;
        }
        
        const li = document.createElement('li');
        const level = heading.tagName === 'H2' ? 'toc-level-2' : 'toc-level-3';
        li.className = `toc-item ${level}`;
        
        const link = document.createElement('a');
        link.href = `#${heading.id}`;
        link.textContent = heading.textContent;
        link.className = 'toc-link';
        
        // Highlight active section on scroll
        link.addEventListener('click', (e) => {
          e.preventDefault();
          heading.scrollIntoView({ behavior: 'smooth', block: 'start' });
          
          // Close mobile TOC after clicking
          if (window.innerWidth < 769) {
            closeTOC();
          }
        });
        
        li.appendChild(link);
        tocList.appendChild(li);
      });
      
      tocNav.appendChild(tocList);
      
      // Highlight active section on scroll
      let ticking = false;
      window.addEventListener('scroll', () => {
        if (!ticking) {
          window.requestAnimationFrame(() => {
            updateActiveTOC();
            ticking = false;
          });
          ticking = true;
        }
      });
    }
    
    function updateActiveTOC() {
      const headings = document.querySelectorAll('.toc-main-content h2, .toc-main-content h3, .article-content h2, .article-content h3');
      const tocLinks = document.querySelectorAll('.toc-link');
      
      if (headings.length === 0 || tocLinks.length === 0) return;
      
      const scrollPosition = window.scrollY + 150;
      
      // Batch all layout reads first to prevent forced reflow
      const headingPositions = Array.from(headings).map(heading => ({
        id: heading.id,
        top: heading.getBoundingClientRect().top + window.scrollY
      }));
      
      // Find the current section based on scroll position
      let current = '';
      headingPositions.forEach(({ id, top }) => {
        if (scrollPosition >= top) {
          current = id;
        }
      });
      
      // If no current section found, use the first heading
      if (!current && headingPositions.length > 0) {
        current = headingPositions[0].id;
      }
      
      // Batch all writes together (no reads after this point)
      let activeLink: Element | null = null;
      tocLinks.forEach(link => {
        const isActive = link.getAttribute('href') === `#${current}`;
        link.classList.toggle('active', isActive);
        if (isActive) {
          activeLink = link;
        }
      });
      
      // Scroll active link into view in a separate frame to avoid reflow
      if (activeLink) {
        requestAnimationFrame(() => {
          activeLink?.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'nearest' });
        });
      }
    }
    
    // Mobile TOC toggle
    const tocToggle = document.getElementById('toc-toggle');
    const tocSidebar = document.getElementById('toc-sidebar');
    const tocClose = document.getElementById('toc-close');
    
    function openTOC() {
      tocSidebar?.classList.add('open');
      if (tocToggle) tocToggle.style.display = 'none';
    }

    function closeTOC() {
      tocSidebar?.classList.remove('open');
      if (tocToggle) tocToggle.style.display = ''; // Reset to default (flex/none based on media query)
    }

    tocToggle?.addEventListener('click', openTOC);
    
    tocClose?.addEventListener('click', closeTOC);
    
    // Close on outside click (mobile)
    document.addEventListener('click', (e) => {
      if (window.innerWidth < 769 && 
          tocSidebar?.classList.contains('open') &&
          !tocSidebar.contains(e.target as Node) &&
          !tocToggle?.contains(e.target as Node)) {
        closeTOC();
      }
    });
    
    // Initialize TOC
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', generateTOC);
    } else {
      generateTOC();
    }
  </script>
)}

{floatingImages && (
  <script is:inline>
    (function() {
        function setupContinuousAnimation() {
           const container = document.querySelector('.floating-container');
           if (!container) return;

           // Prevent double initialization
           if (container.dataset.animStarted) return;
           container.dataset.animStarted = "true";

           // Show container after setup
           container.classList.add('loaded');
           
           const floatingImages = document.querySelectorAll('.floating-image');
           
           // Setup continuous animation logic
           let animationCounter = 0;
           
           function randomRange(min, max) {
             return Math.random() * (max - min) + min;
           }

           function generateKeyframes(index) {
             const keyframeName = `dynamicFloat${animationCounter}_${index}`;
             const waypoints = Math.random() > 0.5 ? 4 : 2;
             const percentages = waypoints === 4 ? [0, 25, 50, 75, 100] : [0, 50, 100];
             let keyframeString = `@keyframes ${keyframeName} {`;
             
             percentages.forEach(percent => {
               const translateX = percent === 0 ? randomRange(-40, -15) : 
                                  percent === 100 ? randomRange(115, 145) : 
                                  randomRange(percent * 1.2 - 30, percent * 1.2 + 10);
               const translateY = randomRange(-20, 20);
               const scale = randomRange(0.7, 1.5);
               const rotate = randomRange(-30, 30);
               keyframeString += `${percent}% { transform: translate(${translateX}vw, ${translateY}vh) scale(${scale}) rotate(${rotate}deg); }`;
             });
             keyframeString += `}`;
             return keyframeString;
           }

           function applyRandomAnimation(element, index) {
             const keyframes = generateKeyframes(index);
             const keyframeName = `dynamicFloat${animationCounter}_${index}`;
             
             let styleTag = document.getElementById(`anim-${index}`);
             if (!styleTag) {
                 styleTag = document.createElement('style');
                 styleTag.id = `anim-${index}`;
                 document.head.appendChild(styleTag);
             }
             styleTag.textContent = keyframes;
             
             const top = randomRange(5, 85);
             const left = randomRange(5, 90);
             const duration = randomRange(33, 50);
             
             element.style.top = `${top}%`;
             element.style.left = `${left}%`;
             element.style.animationName = keyframeName;
             element.style.animationDuration = `${duration}s`;
           }

           // Listen for the end of the initial (and subsequent) animations
           floatingImages.forEach((img, index) => {
             img.addEventListener('animationend', () => {
               animationCounter++;
               applyRandomAnimation(img, index);
             });
           });
        }

        // Defer setup until after page load (after LCP) to avoid blocking main content
        function deferredInit() {
          // Use requestIdleCallback if available, otherwise setTimeout
          if ('requestIdleCallback' in window) {
            requestIdleCallback(setupContinuousAnimation, { timeout: 3000 });
          } else {
            setTimeout(setupContinuousAnimation, 2000);
          }
        }

        // Wait for full page load (after LCP) before initializing animations
        if (document.readyState === 'complete') {
          deferredInit();
        } else {
          window.addEventListener('load', deferredInit);
        }
    })();
  </script>
)}

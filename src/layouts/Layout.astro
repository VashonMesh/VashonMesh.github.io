---
import Header from '../components/header.astro';
import Footer from '../components/footer.astro';
import TableOfContents from '../components/TableOfContents.astro';
import '../global.css';

interface Props {
  title: string;
  maxWidth?: string;
  twoColumn?: boolean;
  floatingImages?: boolean;
  imageCount?: number;
  noWrapper?: boolean;
  showTOC?: boolean;
}

const { 
  title, 
  maxWidth = '1800px', 
  twoColumn = false,
  floatingImages = false,
  imageCount = 12,
  noWrapper = false,
  showTOC = false
} = Astro.props;

// Floating images setup
interface FloatingImageConfig {
  src: string;
  top: number;
  left: number;
  duration: number;
  keyframes: string;
  animationName: string;
  index: number;
}

let floatingImageItems: FloatingImageConfig[] = [];

if (floatingImages) {
  // Predefined list 
  const availableImages = [
    'hero-imgs/birds/golden-pheasant.optimized.webp',
    'hero-imgs/devices/T-DECK-PLUS_7.optimized.webp',
    'hero-imgs/solar/galaxy2.optimized.webp',
    'hero-imgs/devices/m5-lora.optimized.webp',
    'hero-imgs/devices/AC_SL1500.optimized.webp',
    'hero-imgs/devices/Panel-Antenna.optimized.webp',
    'hero-imgs/devices/hfe.optimized.webp',
    'hero-imgs/devices/custom-meshtastic.optimized.webp',
    'hero-imgs/devices/rak.optimized.webp',
    'hero-imgs/solar/sol.optimized.webp',
    'hero-imgs/devices/Wisblock_WisMesh_Pocket_V2_RAK.optimized.webp',
    'hero-imgs/birds/parrot.optimized.webp',
  ];
  
  const shuffledImages = [...availableImages]
    .sort(() => Math.random() - 0.5)
    .slice(0, Math.min(imageCount, availableImages.length));

  // Helper functions for random generation
  const randomRange = (min: number, max: number) => Math.random() * (max - min) + min;

  floatingImageItems = shuffledImages.map((src, index) => {
    const animationName = `staticFloat_${index}`;
    // Generate keyframes
    const waypoints = Math.random() > 0.5 ? 4 : 2;
    const percentages = waypoints === 4 ? [0, 25, 50, 75, 100] : [0, 50, 100];
    
    let keyframeContent = '';
    
    percentages.forEach(percent => {
        const translateX = percent === 0 
        ? randomRange(-40, -15)
        : percent === 100
            ? randomRange(115, 145)
            : randomRange(percent * 1.2 - 30, percent * 1.2 + 10);
        
        const translateY = randomRange(-20, 20);
        const scale = randomRange(0.7, 1.5);
        const rotate = randomRange(-30, 30);
        
        keyframeContent += `
        ${percent}% { transform: translate(${translateX}vw, ${translateY}vh) scale(${scale}) rotate(${rotate}deg); }`;
    });

    const keyframes = `@keyframes ${animationName} { ${keyframeContent} }`;
    
    return {
        src,
        top: randomRange(5, 85),
        left: randomRange(5, 90),
        duration: randomRange(33, 50),
        keyframes,
        animationName,
        index
    };
  });
}
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="description" content="VashonMesh - Community mesh networks connecting neighbors" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="sitemap" href="/sitemap-index.xml" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="generator" content={Astro.generator} />
    
    <!-- DNS prefetch for external resources -->
    <link rel="dns-prefetch" href="https://gc.zgo.at">
    
    <!-- Critical CSS - most important styles inlined for immediate render -->
    <style is:inline>
      :root {
        --bg-primary: #ffffff;
        --bg-secondary: #f9fafb;
        --text-primary: #111827;
      }
      .dark {
        --bg-primary: #0a0a0a;
        --bg-secondary: #1a1a2e;
        --text-primary: #f9fafb;
      }
      * { box-sizing: border-box; }
      body {
        margin: 0;
        padding: 0;
        background: var(--bg-secondary);
        color: var(--text-primary);
        font-family: system-ui, sans-serif;
      }
      .rubik-maps-regular {
        font-family: "Comic Sans MS", "Marker Felt", fantasy, system-ui, sans-serif;
      }
    </style>
    
    <title>{title}</title>
    
    <!-- Allow pages to inject custom SEO meta tags -->
    <slot name="head" />
  </head>
  <body>
    <div class={floatingImages ? "site-wrapper" : ""}>
      <Header />
      {noWrapper ? (
        <slot />
      ) : showTOC ? (
        <div class={`mx-auto px-4 py-8 w-full flex-1 ${floatingImages ? 'page-content' : ''}`} style={`max-width: ${maxWidth}`}>
          <TableOfContents>
            <slot />
          </TableOfContents>
        </div>
      ) : (
        <div class={`mx-auto px-4 py-8 w-full flex-1 ${floatingImages ? 'page-content' : ''}`} style={`max-width: ${maxWidth}`}>
          {twoColumn ? (
            <div class="grid grid-cols-1 md:grid-cols-[1fr_300px] gap-8 items-start">
              <main class="min-w-0 prose">
                <slot />
              </main>
              <aside class="md:sticky md:top-4">
                <slot name="sidebar" />
              </aside>
            </div>
          ) : (
            <main class="max-w-full prose">
              <slot />
            </main>
          )}
        </div>
      )}
      <Footer />
    </div>

    <!-- Floating images container rendered after main content -->
    {floatingImages && (
      <div class="floating-container">
        <style set:html={floatingImageItems.map(item => item.keyframes).join('\n')} />
        {floatingImageItems.map(item => (
            <div class="floating-image" 
                 id={`float-${item.index}`}
                 style={`
                    top: ${item.top}%; 
                    left: ${item.left}%; 
                    animation-name: ${item.animationName}; 
                    animation-duration: ${item.duration}s; 
                    animation-timing-function: linear; 
                    animation-fill-mode: forwards;
                 `}>
              <span class="img-wrapper">
                <img 
                    src={`/${item.src}`} 
                    alt="" 
                    width="80" 
                    height="80" 
                    style="max-width: 80px; width: 80px; height: auto;" 
                    loading="lazy" 
                    decoding="async"
                    fetchpriority="low"
                />
              </span>
            </div>
        ))}
      </div>
    )}
  </body>
  <!-- Web analytics -->
  <!-- Large script slows page loads...turn on after rest settles down.
  script is:inline data-goatcounter="https://vashonmesh.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script -->
</html>

<style is:global>
  /* Base styles handled in global.css */
  
  /* Layout-specific body styling */
  body {
    min-height: 100vh;
    display: flex;
    flex-direction: column;
  }

  /* Responsive breakpoint for two-column layout */
  @media (max-width: 768px) {
    .md\:grid-cols-\[1fr_300px\] {
      grid-template-columns: 1fr;
    }
  }

  /* Max width constraint for XL screens */
  @media (min-width: 1280px) {
    .mx-auto.px-4.py-8 {
      max-width: min(75vw, var(--max-width, 1800px)) !important;
    }
  }
</style>

{floatingImages && (
  <style is:global>
    /* FloatingImages-specific light mode variables */
    html {
      --bg-primary: rgba(255, 255, 255, 0.85);
      --bg-secondary: rgba(249, 250, 251, 0.85);
      --header-bg: rgba(255, 255, 255, 0.95);
      --footer-bg: rgba(243, 244, 246, 0.95);
    }
    
    /* FloatingImages-specific dark mode overrides */
    html.dark {
      --bg-primary: rgba(10, 10, 10, 0.85);
      --bg-secondary: rgba(26, 26, 46, 0.85);
      --header-bg: rgba(17, 24, 39, 0.95);
      --footer-bg: rgba(31, 41, 55, 0.95);
    }

    /* FloatingImages-specific layout styles */
    html {
      background: #f9fafb;
      transition: background-color 0.3s ease;
      width: 100%;
      overflow-x: hidden;
    }

    html.dark {
      background: #0a0a0a;
    }

    body {
      background: transparent;
      overflow-x: hidden;
      position: relative;
      width: 100%;
      max-width: 100vw;
    }

    .site-wrapper {
      position: relative;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      width: 100%;
      max-width: 100vw;
    }

    header {
      position: relative;
      z-index: 100;
    }

    footer {
      position: relative;
      z-index: 100;
      margin-top: auto;
    }

    .page-content {
      flex: 1;
      position: relative;
      z-index: 3;
      pointer-events: none;
    }

    .floating-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: linear-gradient(135deg, #f9fafb 0%, #e5e7eb 50%, #f9fafb 100%);
      overflow: hidden;
      z-index: 2;
      pointer-events: none;
      transition: opacity 0.8s ease, background 0.3s ease;
      max-width: 100%;
      visibility: hidden;
      opacity: 0;
      contain: strict;
    }

    .floating-container.loaded {
      visibility: visible;
      opacity: 1;
    }

    html.dark .floating-container {
      background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #0a0a0a 100%);
    }

    .floating-image {
      position: absolute;
      pointer-events: auto;
      cursor: pointer;
      z-index: 1;
      width: 80px;
      height: auto;
      overflow: visible;
    }

    /* Pause animations until container is loaded */
    .floating-container:not(.loaded) .floating-image {
      animation-play-state: paused !important;
    }

    .floating-image:hover {
      z-index: 200 !important;
    }

    .img-wrapper {
      display: inline-block;
      width: 80px;
      height: auto;
      opacity: 0.5;
      transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
      transform: scale(1);
    }

    .floating-image:hover .img-wrapper {
      opacity: 1 !important;
      transform: scale(2.5) rotate(5deg) !important;
    }

    .floating-image img {
      display: block;
      max-width: 80px !important;
      width: 80px !important;
      height: auto !important;
      border-radius: 8px;
      transition: filter 0.3s ease;
    }

    html.dark .floating-image img {
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      .floating-image {
        width: 50px;
        height: auto;
      }
      
      .img-wrapper {
        width: 50px;
        height: auto;
      }
      
      .floating-image img {
        max-width: 50px !important;
        width: 50px !important;
      }
    }
  </style>
)}

<script>
  // Theme toggle functionality
  function initTheme() {
    const theme = localStorage.getItem('theme') || 'dark';
    if (theme === 'dark') {
      document.documentElement.classList.add('dark');
    } else {
      document.documentElement.classList.remove('dark');
    }
  }

  // Initialize theme immediately
  initTheme();

  // Add event listener after page loads
  document.addEventListener('DOMContentLoaded', () => {
    const toggle = document.getElementById('theme-toggle');
    if (toggle) {
      toggle.addEventListener('click', () => {
        const isDark = document.documentElement.classList.toggle('dark');
        localStorage.setItem('theme', isDark ? 'dark' : 'light');
      });
    }
  });
</script>

{floatingImages && (
  <script is:inline>
    (function() {
        function setupContinuousAnimation() {
           const container = document.querySelector('.floating-container');
           if (!container) return;

           // Prevent double initialization
           if (container.dataset.animStarted) return;
           container.dataset.animStarted = "true";

           // Show container after setup
           container.classList.add('loaded');
           
           const floatingImages = document.querySelectorAll('.floating-image');
           
           // Setup continuous animation logic
           let animationCounter = 0;
           
           function randomRange(min, max) {
             return Math.random() * (max - min) + min;
           }

           function generateKeyframes(index) {
             const keyframeName = `dynamicFloat${animationCounter}_${index}`;
             const waypoints = Math.random() > 0.5 ? 4 : 2;
             const percentages = waypoints === 4 ? [0, 25, 50, 75, 100] : [0, 50, 100];
             let keyframeString = `@keyframes ${keyframeName} {`;
             
             percentages.forEach(percent => {
               const translateX = percent === 0 ? randomRange(-40, -15) : 
                                  percent === 100 ? randomRange(115, 145) : 
                                  randomRange(percent * 1.2 - 30, percent * 1.2 + 10);
               const translateY = randomRange(-20, 20);
               const scale = randomRange(0.7, 1.5);
               const rotate = randomRange(-30, 30);
               keyframeString += `${percent}% { transform: translate(${translateX}vw, ${translateY}vh) scale(${scale}) rotate(${rotate}deg); }`;
             });
             keyframeString += `}`;
             return keyframeString;
           }

           function applyRandomAnimation(element, index) {
             const keyframes = generateKeyframes(index);
             const keyframeName = `dynamicFloat${animationCounter}_${index}`;
             
             let styleTag = document.getElementById(`anim-${index}`);
             if (!styleTag) {
                 styleTag = document.createElement('style');
                 styleTag.id = `anim-${index}`;
                 document.head.appendChild(styleTag);
             }
             styleTag.textContent = keyframes;
             
             const top = randomRange(5, 85);
             const left = randomRange(5, 90);
             const duration = randomRange(33, 50);
             
             element.style.top = `${top}%`;
             element.style.left = `${left}%`;
             element.style.animationName = keyframeName;
             element.style.animationDuration = `${duration}s`;
           }

           // Listen for the end of the initial (and subsequent) animations
           floatingImages.forEach((img, index) => {
             img.addEventListener('animationend', () => {
               animationCounter++;
               applyRandomAnimation(img, index);
             });
           });
        }

        // Defer setup until after page load (after LCP) to avoid blocking main content
        function deferredInit() {
          // Use requestIdleCallback if available, otherwise setTimeout
          if ('requestIdleCallback' in window) {
            requestIdleCallback(setupContinuousAnimation, { timeout: 3000 });
          } else {
            setTimeout(setupContinuousAnimation, 2000);
          }
        }

        // Wait for full page load (after LCP) before initializing animations
        if (document.readyState === 'complete') {
          deferredInit();
        } else {
          window.addEventListener('load', deferredInit);
        }
    })();
  </script>
)}
